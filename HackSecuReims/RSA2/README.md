#[Crypto] RSA2 

L'énoncé nous donne simplement les valeurs suivantes :
```
e = 65537 
n = 23536956678174521373480059438114155489229264775689354517306867324350893363896328038342862232737243752608062239661318294157994619586188633724625826178863529105386516845636967564614090255485351701391262619446136386295487959829279799963558350091774281194999532852245372577441090805566049759547710875049179069622061682190547858963359642147529732653252899308933116271869805488962168886534490129777331934442638204120495255495277193410694528240677139886323686876510647008388690977109296421328721171371594833765406547521350439962528436244585363053315400494173818638056915576428897444207482967915251805256260424268581135088531 
dp = 150371848368575281611172257822853602904145223544693335581225068816510949815968538314367995341510497600370211899649425046471753419246712799543845116714082911972233671424432079427938159805675230618033999433287353166708263082712093339259387968827786078858442488261269876581324762492565499964034077514672709592225 
c = 15994615838963245491535647132817873302615488790385844407712289794731680172160208795371821707972981786062993784233757636659878799750171751792501379474709752304581231946621711477197518339403495748283065017895688197687562323806032828275735232631202664338668934007210192415895269555304114189228381381150773658516370435223210613036585499335868296993562025268246938616068075088101114999297435456743143728685284369852405149033472178455170992718084832445013387320931830338579184927488203918791560499030437375020776303941391853983851334973148667016982470139003946909723866309974448777210415852420748367852901796725845514849026
```
`e` et `n` forment la clé publique, et `c` est le message chiffré, mais on est ici en possession d'une valeur supplémentaire appelée `dp`. Cette valeur est calculée ainsi : `dp = d mod p-1` et sert dans les calculs d'optimisation grâce au Théorème des Restes Chinois. Heureusement, pas besoin de faire des maths à 3h du matin pour trouver la solution, puisque des posts existent déjà pour expliquer comment calculer `p` à partir de `dp` : https://crypto.stackexchange.com/questions/46486/rsa-given-n-e-dp-is-it-possible-to-find-d

On applique donc la méthode donnée par `poncho` pour retrouver p :

```
$ python
Python 3.8.1 (default, Jan 22 2020, 06:38:00) 
[GCC 9.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> e = 65537 
>>> n = 23536956678174521373480059438114155489229264775689354517306867324350893363896328038342862232737243752608062239661318294157994619586188633724625826178863529105386516845636967564614090255485351701391262619446136386295487959829279799963558350091774281194999532852245372577441090805566049759547710875049179069622061682190547858963359642147529732653252899308933116271869805488962168886534490129777331934442638204120495255495277193410694528240677139886323686876510647008388690977109296421328721171371594833765406547521350439962528436244585363053315400494173818638056915576428897444207482967915251805256260424268581135088531 
>>> dp = 150371848368575281611172257822853602904145223544693335581225068816510949815968538314367995341510497600370211899649425046471753419246712799543845116714082911972233671424432079427938159805675230618033999433287353166708263082712093339259387968827786078858442488261269876581324762492565499964034077514672709592225
>>> e = 65537 
>>> r = 1111111111
>>> def gcd(a, b):
...     while b:
...         a, b = b, a%b
...     return a
... 
>>> p = gcd(n, pow(r,e*dp,n) - r)
>>> p
154277213227266323788337084143779651421913108041087183912876848602455902158632551042749229949224670171819132992068073034074631388540214420359199997089621650676669246440762158950949985584779385532015626989876847498145831704995498625114163081390566646578567665756267320540879190949548595308915453490702673354609
>>> n%p
0
```
On a donc bien retrouvé `p`, l'un des facteurs de `n`. On peut ensuite le factoriser pour retrouver `q`, puis calculer `d` pour pouvoir déchiffrer le message.

```python
e = 65537 
n = 23536956678174521373480059438114155489229264775689354517306867324350893363896328038342862232737243752608062239661318294157994619586188633724625826178863529105386516845636967564614090255485351701391262619446136386295487959829279799963558350091774281194999532852245372577441090805566049759547710875049179069622061682190547858963359642147529732653252899308933116271869805488962168886534490129777331934442638204120495255495277193410694528240677139886323686876510647008388690977109296421328721171371594833765406547521350439962528436244585363053315400494173818638056915576428897444207482967915251805256260424268581135088531 
dp = 150371848368575281611172257822853602904145223544693335581225068816510949815968538314367995341510497600370211899649425046471753419246712799543845116714082911972233671424432079427938159805675230618033999433287353166708263082712093339259387968827786078858442488261269876581324762492565499964034077514672709592225 
c = 15994615838963245491535647132817873302615488790385844407712289794731680172160208795371821707972981786062993784233757636659878799750171751792501379474709752304581231946621711477197518339403495748283065017895688197687562323806032828275735232631202664338668934007210192415895269555304114189228381381150773658516370435223210613036585499335868296993562025268246938616068075088101114999297435456743143728685284369852405149033472178455170992718084832445013387320931830338579184927488203918791560499030437375020776303941391853983851334973148667016982470139003946909723866309974448777210415852420748367852901796725845514849026

p = 154277213227266323788337084143779651421913108041087183912876848602455902158632551042749229949224670171819132992068073034074631388540214420359199997089621650676669246440762158950949985584779385532015626989876847498145831704995498625114163081390566646578567665756267320540879190949548595308915453490702673354609

q = n//p

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

phi_n = (p-1)*(q-1)
d = modinv(e, phi_n)

m = pow(c,d,n)
print(bytes.fromhex('0'+hex(m)[2:]))
```

Et l'exécution nous donne le flag : HSR{RSA\_d0n3\_w1th\_l0v3\_...}
